import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import {
  createCertificateFromDesignAndType,
  getCertificateTypeById,
  getDesignTemplateById,
  CERTIFICATE_TYPES,
  DESIGN_TEMPLATES,
  TemplateData, // Now correctly imported due to export type in design-system
} from "@/lib/utils/certificate-design-system";
import { DatabaseCertificateService } from "@/lib/services/certificate-database";
import { Prisma } from "@prisma/client";
import { FOM_ORGANIZATION } from "@/lib/utils/certificate-manager"; // For default org colors

export async function GET() {
  try {
    return NextResponse.json({
      certificateTypes: CERTIFICATE_TYPES,
      designTemplates: DESIGN_TEMPLATES,
    });
  } catch (error) {
    console.error("Error fetching design system options:", error);
    return NextResponse.json(
      { error: "Failed to fetch design system options" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session?.user?.email) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const {
      certificateTypeId,
      designTemplateId,
      recipientName,
      recipientEmail,
      customFields: bodyCustomFields = {},
      securityLevel = "STANDARD",
      validityPeriod = null, // in days, or null
      notes = "",
    } = body;

    if (
      !certificateTypeId ||
      !designTemplateId ||
      !recipientName ||
      !recipientEmail
    ) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    const certificateType = getCertificateTypeById(certificateTypeId);
    const designTemplate = getDesignTemplateById(designTemplateId);

    if (!certificateType || !designTemplate) {
      return NextResponse.json(
        { error: "Invalid certificate type or design template" },
        { status: 400 }
      );
    }

    const issuerDisplayName =
      session.user.displayName ||
      `${session.user.firstName || ""} ${session.user.lastName || ""}`.trim() ||
      "System Administrator";

    // Don't pre-generate the ID here - let the CertificateManager handle it with proper sequence tracking
    const issueDate = new Date().toLocaleDateString();

    const resolvedCertificateDesign: TemplateData | null =
      createCertificateFromDesignAndType(designTemplateId, certificateTypeId, {
        recipientName,
        issuerName: issuerDisplayName,
        customFields: bodyCustomFields,
        issueDate: issueDate,
        // Don't pass certificateId yet - it will be generated by the database
        // and replaced during rendering, not during template creation
      });

    if (!resolvedCertificateDesign) {
      return NextResponse.json(
        { error: "Failed to generate certificate template data" },
        { status: 500 }
      );
    }

    const fullTemplateDesignForDb: Prisma.JsonObject = JSON.parse(
      JSON.stringify(resolvedCertificateDesign)
    );

    console.log("Template design to store in DB:", {
      hasElements: !!resolvedCertificateDesign?.elements,
      elementsCount: resolvedCertificateDesign?.elements?.length || 0,
      templateName: resolvedCertificateDesign?.name,
      keys: Object.keys(fullTemplateDesignForDb),
      fullTemplateDesignForDb,
    });

    const dbService = new DatabaseCertificateService();
    let organizationId: string;

    // Since User model doesn't have organizationId, we'll use FOM as default or find/create one
    const userOrganizations = await dbService.getOrganizations();
    const existingUserOrgByName = userOrganizations.find((org) =>
      org.name.includes(issuerDisplayName)
    );
    if (existingUserOrgByName) {
      organizationId = existingUserOrgByName.id;
    } else {
      const fomOrg = userOrganizations.find((org) => org.slug === "fom");
      if (fomOrg) {
        organizationId = fomOrg.id;
      } else {
        // Create a new default-like organization if FOM itself is missing (should be rare)
        const newOrg = await dbService.createOrganization({
          name: `Organization for ${issuerDisplayName || session.user.email}`,
          tagline: "Default Organization Tagline",
          logo: "/Logo.png",
          colors: FOM_ORGANIZATION.colors, // Use default FOM colors
          leadership: {}, // Add empty leadership object
        });
        organizationId = newOrg.id;
      }
    }

    const managerCustomFields: Record<string, unknown> = {
      ...bodyCustomFields,
      _notesFromFlexibleIssue: notes,
      _certificateTypeNameFromDesignSystem: certificateType.name,
      _designTemplateNameFromDesignSystem: designTemplate.name,
      _issuerDisplayName: issuerDisplayName,
      _issueDate: issueDate, // Add issue date to manager custom fields for potential use
    };

    const issuedCertificate = await dbService.issueCertificate(
      {
        // Remove id - let CertificateManager generate it with proper sequence tracking
        templateName: designTemplate.name, // This is the design template's name (e.g., "Classic Elegant")
        recipientName,
        customFields: managerCustomFields,
        securityLevel,
        organizationId,
        issuedBy: session.user.id,
        validityPeriod: validityPeriod,

        recipientEmail,
        issuedById: session.user.id,
      },
      fullTemplateDesignForDb
    );

    return NextResponse.json({
      success: true,
      certificate: {
        id: issuedCertificate.id,
        certificateId: issuedCertificate.id,
        recipientName: issuedCertificate.recipientName,
        issuedAt: issuedCertificate.issueDate,
        expiryDate: issuedCertificate.expiryDate,
        templateData: fullTemplateDesignForDb,
        verificationUrl: issuedCertificate.verificationUrl,
      },
    });
  } catch (error) {
    console.error("Error issuing flexible certificate in API route:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Failed to issue certificate";
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
